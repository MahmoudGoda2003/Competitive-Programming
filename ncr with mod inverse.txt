pascal function---

vector<vector<ll>> pas(1001, vector<ll>(1001, 0));
 
void build()
{
    pas[0][0] = 1;
    for (int i = 1; i < N; i++)
    {
        pas[i][0] = 1;
        for (int j = 1; j < N; j++)
        {
            pas[i][j] = pas[i - 1][j] + pas[i - 1][j - 1];
            pas[i][j] %= mod;
        }
    }
} 


/* Iterative Function to calculate (x^y)%p
in O(log y) */
unsigned long long power(unsigned long long x,int y, int p) {
    unsigned long long res = 1; // Initialize result
 
    x = x % p; // Update x if it is more than or
 
    while (y > 0) {
        if (y & 1)
            res = (res * x) % p;
 
        y = y >> 1; // y = y/2
        x = (x * x) % p;
    }
    return res;
}
 
// Returns n^(-1) mod p
unsigned long long modInverse(unsigned long long n,int p)
{
return power(n, p - 2, p);
}
 
// Returns nCr % p using Fermat's little
// theorem.
unsigned long long nCrModPFermat(unsigned long long n,
int r, int p) {
// If n<r, then nCr should return 0
    if (n < r)
        return 0;
// Base case
    if (r == 0)
        return 1;
 
    unsigned long long fac[n + 1];
    fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % p;
 
    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;
}