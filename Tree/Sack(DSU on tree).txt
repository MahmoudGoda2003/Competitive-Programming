////////////////////////////////////


sack problems used to in cases of offline queries(no update operations)


int sz[N],dep[N];
vector<vll>g(N);
string str;
void getsz(int v, int p){
    sz[v] = 1;
    dep[v]=1;
    if(p!=-1)
        dep[v]=dep[p]+1;
    for(auto u : g[v])
        if(u != p){
            getsz(u, v);
            sz[v] += sz[u];
        }
}

vector<vector<pi>>query(N);
vector<bool>visited(N,0);
vector<vi>values(N,vi(28,0));
vi res(N);
void insertInValues(int node){ ///insert new subtree(changable)
    char ch=str[node-1];
    values[dep[node]][str[node-1]-'a']++;
    fvec(item,g[node]){
        if(!visited[item])
            insertInValues(item);
    }
}
void clearFromValues(int node){   /// clear un keeped subtree(changable)
    char ch=str[node-1];
    values[dep[node]][str[node-1]-'a']--;
    fvec(item,g[node]){
        if(!visited[item])clearFromValues(item);
    }
}
void dfs(int node,int par,bool keep=0){    // all sack problems has same imp but some changes in insertion implementation 


    int maxSz=-1,greatNode=-1;
    fvec(item,g[node]){//(un changable)
        if(sz[item]>maxSz){
            maxSz=sz[item];
            greatNode=item;
        }
    }
    fvec(item,g[node]){//(un changable)
        if(item!=par&&greatNode!=item)
        {
            dfs(item,node,0);
        }
    }
    if(maxSz!=-1){//(un changable)
        dfs(greatNode,node,1);
        visited[greatNode]=1;
    }
    insertInValues(node);
    fvec(item,query[node]){ //(changable)--> queries calculation
        ll index=item.S,h=item.F;
        if(dep[node]>h){
            res[index]=1;
            continue;
        }
        ll oddCount=0;
        fo(i,27){
           oddCount+=values[h][i]%2;
        }
        if(oddCount>1){
            res[index]=0;
        }else{
            res[index]=1;
        }
    }
    if(maxSz!=-1)visited[greatNode]=0;//(un changable)
    if(keep == false){ //(un changable)
        clearFromValues(node);
    }
}


////////////////////////////////////////////////////////////////////////

https://codeforces.com/contest/1805/problem/E

// sack problem to handle in and out Subtree

vector<vector<int>>g(N);
vector<int>cost(N);
set<int>two;
ll maxTake=0;
map<int,int>costssss;
int sz[N],dep[N];
vector<vector<pair<int,int>>>query(N);
vector<bool>visited(N,0);
set<int>in,out;
map<int,int>inM,outM;
vector<int> res(N);
map<pair<int,int>,int>edges;
void getsz(int v, int p){
    sz[v] = 1;
    dep[v]=1;
    if(p!=-1)
        dep[v]=dep[p]+1;
    for(auto u : g[v])
        if(u != p){
            getsz(u, v);
            sz[v] += sz[u];
        }
}


void insertInValues(int node,int par){ ///insert new subtree(changable)

    ll c=cost[node];
    if(outM[c]==2){
        out.erase(c);
    }else in.insert(c);
    outM[c]--;
    inM[c]++;
    for(auto item:g[node]){
        if(!visited[item]&&item!=par)
            insertInValues(item,node);
    }
}
void clearFromValues(int node,int par){   /// clear un keeped subtree(changable)
    ll c=cost[node];
    if(inM[c]==2){
        in.erase(c);
    }else out.insert(c);
    outM[c]++;
    inM[c]--;
    for(auto item:g[node]){
        if(!visited[item]&&par!=item)
            clearFromValues(item,node);
    }
}
void dfs(int node,int par,bool keep=0){    // all sack problems has same imp but some changes in insertion implementation
    int maxSz=-1,greatNode=-1;
    for(auto item:g[node]){//(un changable)
        if(item==par)continue;
        if(sz[item]>maxSz){
            maxSz=sz[item];
            greatNode=item;
        }
    }
    for(auto item:g[node]){//(un changable)
        if(item!=par&&greatNode!=item)
        {
            dfs(item,node,0);
        }
    }
    if(maxSz!=-1){//(un changable)
        dfs(greatNode,node,1);
        visited[greatNode]=1;
    }
    insertInValues(node,par);

    ll ans=maxTake;

    if(out.size())ans=max(ans,*out.rbegin());

    if(in.size())ans=max(ans,*in.rbegin());

    res[edges[{min(node,par),max(node,par)}]]=ans;

    if(maxSz!=-1)
        visited[greatNode]=0;//(un changable)

    if(keep == false){ //(un changable)
        clearFromValues(node,par);
    }
}